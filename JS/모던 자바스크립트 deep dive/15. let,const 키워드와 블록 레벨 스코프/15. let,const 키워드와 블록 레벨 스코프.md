#### let, const 키워드와 블록 레벨 스코프

<br>

##### var 키워드로 선언한 변수의 문제점

변수 중복 선언 허용

```javascript
var x = 1;
var y = 10;

var x = 100;
var y;
```

함수레벨 스코프

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 

- 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다.

변수 호이스팅

- 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.

- 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

<br>

##### let 키워드

var 키워드와의 차이점을 중심으로 보기

변수 중복 선언 금지

```javascript
let bar = 123;
let bar = 456 //SyntaxError: Identifier 'bar' has already been declared
```

블록레벨 스코프

- 모든 코드블록을 지역 스코프로 인정

변수 호이스팅

- 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.

- var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 '선언'과 '초기화'가 한번에 진행된다. 즉 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록해 JS엔진에 변수의 존재를 알린다. 그리고 즉시 초기화 단계에서 undefined로 변수를 초기화 한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다.

- let 키워드로 선언한 변수는 '선언'과 '초기화'가 분리되어 진행된다. 런타임 이전에 JS엔진에 의해 '선언'되는 것은 동일하나, 초기화 단계는 변수 선언문에 도달했을 때 실행 된다.

- 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(temporal dead zone)이라고 부른다.

전역객체와 let

- var 키워드로 선언한 변수는 전역 객체 window의 프로퍼티가 된다. (window.x)와 같이 접근 가능.

- let 키워드로 선언한 변수는  전역 객체 window의 프로퍼티가 아니다. 

<br>

##### const 키워드

let과 차이점을 중심으로

선언과 초기화

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다.

- 그렇지 않으면 다음과 같은 문법에러

```javascript
const foo; //SyntaxError : Missing initializer in const declaration
```

재할당금지

- var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const키워드로 선언한 변수는 재할당이 금지 된다.

상수

- const 키워드를 상수를 표현하는 데 사용하기도 한다.

- 원시 값을 할당한 경우 값은 변경 불가능

const키워드와 객체

- 객체를 할당한 경우 값을 변경할 수 있다. 

- 재할당ㅇ르 금지할 뿐 '불변'을 의미하지는 않는다.
